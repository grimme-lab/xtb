ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine rotmol(n,xyz,xrot,yrot,zrot)
      implicit none
      integer n,i
      real*8 xrot,yrot,zrot,xyz(3,n)
      real*8 ang,pi,xo,yo             
      data pi/3.1415926535897932384626433832795029d0/

         ang=xrot*pi/180.0d0
         do i=1,n
            xo=xyz(2,i)
            yo=xyz(3,i)
            xyz(2,i)= xo*cos(ang)+yo*sin(ang)
            xyz(3,i)=-xo*sin(ang)+yo*cos(ang)
         enddo
         ang=yrot*pi/180.0d0
         do i=1,n
            xo=xyz(1,i)
            yo=xyz(3,i)
            xyz(1,i)= xo*cos(ang)+yo*sin(ang)
            xyz(3,i)=-xo*sin(ang)+yo*cos(ang)
         enddo
         ang=zrot*pi/180.0d0
         do i=1,n
            xo=xyz(1,i)
            yo=xyz(2,i)
            xyz(1,i)= xo*cos(ang)+yo*sin(ang)
            xyz(2,i)=-xo*sin(ang)+yo*cos(ang)
         enddo

      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine g98fake2(fname,n,at,xyz,freq,red_mass,ir_int,u2,u)
      implicit none
      integer n,at(n)
      real*8 u(3*n,3*n),freq(3*n),xyz(3,n),u2(3*n,3*n)
      real*8 red_mass(3*n)
      real*8 ir_int  (3*n)
      character*(*) fname
      
      integer gu,i,j,ka,kb,kc,la,lb,k
      character*2 irrep
      real*8 red     (3*n)
      real*8 f2      (3*n)
      real*8 ir      (3*n)
      real*8 zero

      irrep='a'
      zero    =0.0

      k=0
      do i=1,3*n
         if(abs(freq(i)).gt.1.d-1)then
            k=k+1
            u(1:3*n,k)=u2(1:3*n,i)
            f2(k)=freq(i)
            ir(k)=ir_int(i)
            red(k)=red_mass(i)
         endif
      enddo

      gu=55
      open(unit=gu,file=fname,status='unknown')
      write (gu,'('' Entering Gaussian System'')')
      write (gu,'('' *********************************************'')')
      write (gu,'('' Gaussian 98:'')')
      write (gu,'('' frequency output generated by the xtb code'')')
      write (gu,'('' *********************************************'')')

      write (gu,*) '                        Standard orientation:'
      write (gu,*) '---------------------------------------------',
     .             '-----------------------'
      write (gu,*) ' Center     Atomic     Atomic',
     .             '              Coordinates (Angstroms)'
      write (gu,*) ' Number     Number      Type ',
     .             '             X           Y           Z'
      write (gu,*) '-----------------------',
     .             '---------------------------------------------'
      j=0
      do i=1,n
       write(gu,111) i,at(i),j,xyz(1:3,i)*0.52917726
      enddo
      write (gu,*) '----------------------',
     .              '----------------------------------------------'
      write (gu,*) '    1 basis functions        1 primitive gaussians'
      write (gu,*) '    1 alpha electrons        1 beta electrons'
      write (gu,*)
111   format(i5,i11,i14,4x,3f12.6)

      write (gu,*) 'Harmonic frequencies (cm**-1), IR intensities',
     .              ' (KM/Mole),'
      write (gu,*) 'Raman scattering activities (A**4/amu),',
     .              ' Raman depolarization ratios,'
      write (gu,*) 'reduced masses (AMU), force constants (mDyne/A)',
     .              ' and normal coordinates:'

      ka=1
      kc=3
60    kb=min0(kc,k)  
      write (gu,100) (j,j=ka,kb)
      write (gu,105) (irrep,j=ka,kb)
      write (gu,110) ' Frequencies --',(f2(j),j=ka,kb)
      write (gu,110) ' Red. masses --',(red(j),j=ka,kb)
      write (gu,110) ' Frc consts  --',(zero,j=ka,kb)
      write (gu,110) ' IR Inten    --',(ir(j),j=ka,kb)
      write (gu,110) ' Raman Activ --',(zero,j=ka,kb)
      write (gu,110) ' Depolar     --',(zero,j=ka,kb)
      write (gu,*)'Atom AN      X      Y      Z        X      Y',
     .            '      Z        X      Y      Z'
      la=1
70    lb=n
      do  i=la,lb
        write (gu,130) i,at(i),  
     .              (u(i*3-2,j),  
     .               u(i*3-1,j),  
     .               u(i*3  ,j),j=ka,kb)
      enddo
      if (lb.eq.n) go to 90
      go to 70
90    if (kb.eq.k) then
       return
      endif
      ka=kc+1
      kc=kc+3
      go to 60

100   format (3(20x,i3))
105   format (3x,3(18x,a5))
110   format (a15,f11.4,12x,f11.4,12x,f11.4)
130   format (2i4,3(2x,3f7.2))

      write(gu,'(''end of file'')')
      close(gu)
      return

      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine trproj(natoms,nat3,xyz,hess,ldebug,nmode,mode,ndim)

c----------------------------------------------------------------------
c  subroutine trproj drives projection of hessian out of the 
c  space of translational and rotational motions: 
c  first get xyz c.m.; second get transl. and rot. projection matrix  
c
c  get center of mass coordinates with unit mass
c
c Input
c 	natoms 	= number of atoms
c 	nat3	= 3*natoms
c 	xyz	= cartesian coordinates
c       ldebug  = debug flag = .true. for debugging
c
c Ouput fo gtrprojm.f
c	xyzucm	= temporary c.m. coordinates
c
c       hess  	= projected hessian out of space of transl. and rot.
c                 motion
c
c----------------------------------------------------------------------
c Input
      logical, intent(in) :: ldebug
      integer, intent(in) :: natoms,nat3,nmode,ndim
      real*8, dimension(3,natoms) :: xyz
      real*8, dimension(nat3,ndim):: mode   
c Ouput
      real*8, dimension(nat3*(nat3+1)/2) :: hess
c Local
      integer :: i
      real*8 :: xm,ym,zm
      real*8, dimension(3,natoms) ::xyzucm
 
      xyzucm(:,:) = xyz(:,:)

      xm = 0.0d0
      ym = 0.0d0
      zm = 0.0d0

      do i=1,natoms
         xm = xm + xyzucm(1,i)
         ym = ym + xyzucm(2,i)
         zm = zm + xyzucm(3,i)
      end do
      
      xm = xm/natoms
      ym = ym/natoms
      zm = zm/natoms
      
      
      do i=1,natoms
         xyzucm(1,i) = xyzucm(1,i) - xm
         xyzucm(2,i) = xyzucm(2,i) - ym
         xyzucm(3,i) = xyzucm(3,i) - zm
      end do

c get translational and rotational projection matrix

      call gtrprojm(natoms,nat3,xyzucm,hess,ldebug,nmode,mode,ndim)

      end subroutine trproj

c----------------------------------------------------------------------
      subroutine gtrprojm(natoms,nat3,xyzucm,hess,ldebug,
     .                    nmode,mode,ndim)
      use mctc_la             

c----------------------------------------------------------------------
c calculating the translational-rotational projection matrix
c
c Input
c 	natoms 	= number of atoms
c	nat3	= 3*natoms
c 	xyzucm	= coords c.m. from gxyzucm.f
c      	hess	= hessian
c       ldebug	= debug flag = .true. for debugging
c
c Ouput
c 	fmat	= F-matrix with translational and rotational vectors
c       pmat	= projection matrix P = (1-FFt)
c  	hess	= projected hessian
c----------------------------------------------------------------------

c Input
      logical, intent(in) :: ldebug
      integer, intent(in) :: natoms,nat3,nmode,ndim
      real*8, dimension(3,natoms) :: xyzucm
      real*8, dimension(nat3,ndim):: mode   
c Ouput
      real*8, dimension(nat3*(nat3+1)/2) :: hess

c Local
      integer :: i,ii,iii
      real*8, allocatable :: fmat(:,:)

      nprj=6
      if(nmode.gt.0) nprj=nprj+nmode
      if(nmode.lt.0) nprj=nprj+natomsf*3
      if(nmode.eq.9999) nprj=nprj-3      ! keep rot
      allocate(fmat(nat3,nprj))
      fmat(:,:) = 0.0d0

      do i=1,natoms
         do ii=1,3
c        translation vectors
         fmat(3*(i-1)+ii,ii) = 1.0d0
         end do
c        rotational vectors
         if(nmode.eq.9999) cycle ! keep rot       
         fmat(3*(i-1)+1,4) =  0.0d0
         fmat(3*(i-1)+2,4) = -xyzucm(3,i)
         fmat(3*(i-1)+3,4) =  xyzucm(2,i)
         fmat(3*(i-1)+1,5) =  xyzucm(3,i)
         fmat(3*(i-1)+2,5) =  0.0d0
         fmat(3*(i-1)+3,5) = -xyzucm(1,i)
         fmat(3*(i-1)+1,6) = -xyzucm(2,i) 
         fmat(3*(i-1)+2,6) =  xyzucm(1,i)
         fmat(3*(i-1)+3,6) =  0.0d0
      end do

      if(ldebug) then
         write(*,'(a)')
         write(*,'(a)') ' Basis vectors before orthonormalization'
         write(*,'(3e22.14)') fmat
      end if

c do orthogonalization 

      call  blckmgs(nat3,nprj,nat3,fmat)
      
c do projection

      call dsyprj(nat3,nprj,fmat,nat3,hess)

      deallocate(fmat)
      
      end subroutine gtrprojm


      subroutine wrhess(nat3,h,fname)
      implicit none
      integer nat3
      real*8 h(nat3*(nat3+1)/2)
      character*(*) fname
      integer iunit,i,j,mincol,maxcol,lin,k
      character*5 adum
      character*80 a80

      adum='   '
      iunit=1
      open(unit=iunit,file=fname)
      a80='$hessian'
      write(iunit,'(a)')a80
      do 100 i=1,nat3
        maxcol = 0
        k=0
  200   mincol = maxcol + 1
        k=k+1
        maxcol = min(maxcol+5,nat3)
        write(iunit,'(a5,5f15.10)')adum,
     .  (h(lin(i,j)),j=mincol,maxcol)
        if (maxcol.lt.nat3) goto 200
  100 continue
      close(iunit)

      end

      subroutine rdhess(nat3,h,fname)
      implicit none
      integer nat3
      real*8 h(nat3,nat3)
      character*(*) fname
      integer iunit,i,j,mincol,maxcol
      character*5 adum
      character*80 a80

c     write(*,*) 'Reading Hessian <',trim(fname),'>'
      iunit=1
      open(unit=iunit,file=fname)
   50 read(iunit,'(a)')a80
      if(index(a80,'$hessian').ne.0)then
      do 100 i=1,nat3
        maxcol = 0
  200   mincol = maxcol + 1
        maxcol = min(maxcol+5,nat3)
        read(iunit,'(a5   ,5f15.10)')adum ,(h(i,j),j=mincol,maxcol)
        if (maxcol.lt.nat3) goto 200
  100 continue
      close(iunit)
      goto 300
      endif
      goto 50

  300 return
      end

